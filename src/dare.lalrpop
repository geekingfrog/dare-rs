#![allow(dead_code)]

use crate::lexer;
use crate::ast::{
  Struct,
  Enum,
  Type,
  AtomicType,
  RefType,
  Field,
  EnumVariant,
  VariantValue,
  TopDeclaration,
  Alias,
  Builtin,
  location,
};

grammar;

pub TopDeclarations: Vec<TopDeclaration<String>> = {
  TopDeclaration* => <>,
}

pub TopDeclaration: TopDeclaration<String> = {
  Struct => TopDeclaration::Struct(<>),
  Enum => TopDeclaration::Enum(<>),
}

pub Struct: Struct<String> = {
  <s:@L> "struct" <name:Word> <params: TopLevelParams> "{" <fields:Comma<Field>> "}" <e:@L> => Struct {
    location: location(s, e),
    name: name.to_string(),
    type_parameters: params,
    fields,
  }
}

pub Enum: Enum<String> = {
  <s:@L> "enum" <name:Word> <params: TopLevelParams> "{" <variants:Comma<EnumVariant>> "}" <e:@L> => Enum {
    location: location(s, e),
    name: name.to_string(),
    type_parameters: params,
    variants,
  }
}

pub Alias: Alias<String> = {
  <s:@L> "type" <name:Word> "=" <alias:RefType> <e:@L> => Alias {
    location: location(s, e),
    name: name.to_string(),
    alias,
  }
}

pub RefType: RefType<String> = {
  <s:@L> <n:Word> <params:("<" <Comma<Type>> ">")?> <e:@L> => RefType {
    location: location(s, e),
    name: n.to_string(),
    type_parameters: params.unwrap_or(vec![]),
  },
}

pub Field: Field<String> = {
  <s:@L> <name:word> ":" <typ: Type> <e:@L> => Field {
    location: location(s, e),
    name: name.to_string(),
    typ,
  },
}

pub Type: Type<String> = {
  <atom:AtomicType> => Type::Atomic(atom),
  <s:@L> <n:Word> <types:("<" <Comma<Type>> ">")?> <e:@L> => Type::Reference(RefType {
    location: location(s, e),
    name: n.to_string(),
    type_parameters: types.unwrap_or(vec![]),
  }),

  // ditch the anon structs for use in list List<{...}> (at least for now)
  // "{" <fields:Comma<Field>> "}" => Type::Anonymous(fields),

  "List" "<" <typ:Type> ">" => Type::Builtin(Builtin::List(Box::new(typ))),
  "[" <typ:Type> "]" => Type::Builtin(Builtin::List(Box::new(typ))),

  "Optional" "<" <typ:Type> ">" => Type::Builtin(Builtin::Optional(Box::new(typ))),
  <typ:Type>"?" => Type::Builtin(Builtin::Optional(Box::new(typ))),

  "Map" "<" <key:Type> "," <val:Type> ">" => Type::Builtin(Builtin::Map(
    Box::new(key),
    Box::new(val),
  )),
}


TopLevelParams: Vec<String> = {
  <x:("<" <Comma<Word>> ">")?> => match x {
    None => vec![],
    Some(params) => {
      params.into_iter().map(|p| p.to_string()).collect()
    }
  }
}

EnumVariant: EnumVariant<String> = {
  <s:@L> <name:Word> <value:VariantValue> <alias:("as" <quoted_word>)?> <e:@L> => EnumVariant {
    location: location(s, e),
    name: name.to_string(),
    alias: alias.map(|x| x.to_string()),
    value,
  }
}

VariantValue: VariantValue<String> = {
  "{" <fields:Comma<Field>> "}" => VariantValue::StructCtor(
    fields
  ),
  <x:("(" <Comma<Type>> ")")?> => match x {
    None => VariantValue::OnlyCtor,
    Some(typs) => VariantValue::PositionalCtor(typs),
  }
}


pub AtomicType: AtomicType = {
  "String" => AtomicType::Str,
  "UInt" => AtomicType::UInt,
  "Int" => AtomicType::Int,
  "Int8" => AtomicType::Int8,
  "Int16" => AtomicType::Int16,
  "Int32" => AtomicType::Int32,
  "Int64" => AtomicType::Int64,
  "UInt8" => AtomicType::UInt8,
  "UInt16" => AtomicType::UInt16,
  "UInt32" => AtomicType::UInt32,
  "UInt64" => AtomicType::UInt64,
  "Float" => AtomicType::Float,
  "Bool" => AtomicType::Bool,
  "Bytes" => AtomicType::Bytes,
}

// comma separated vector of T, with optional trailing comma
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// quoted_word: String = <w:quoted_word_r> => w[1..w.len()-1].to_string();

// match {
//   "as",
//   "struct",
//   "enum",
//   "type",
//   "List",
//   "Map",
//   "Optional",
//   "String",
//   "UInt",
//   "Int",
//   "Int8",
//   "Int16",
//   "Int32",
//   "Int64",
//   "UInt8",
//   "UInt16",
//   "UInt32",
//   "UInt64",
//   "Float",
//   "Bool",
//   "Bytes",
// } else {
//   r#""[^"]*""# => quoted_word_r,
// } else {
//   r"[A-Z]\w*" => Word,
// } else {
//   r"[a-z]\w*" => word,
//   _,
// }

extern {
  type Location = lexer::Loc;
  type Error = lexer::LexicalError;

  enum lexer::Tok {
    "("               => lexer::Tok::OpenParens,
    ")"               => lexer::Tok::CloseParens,
    "{"               => lexer::Tok::OpenBrace,
    "}"               => lexer::Tok::CloseBrace,
    "["               => lexer::Tok::OpenBracket,
    "]"               => lexer::Tok::CloseBracket,
    "<"               => lexer::Tok::LesserThan,
    ">"               => lexer::Tok::GreaterThan,
    ","               => lexer::Tok::Comma,
    "?"               => lexer::Tok::QuestionMark,
    "="               => lexer::Tok::Equal,
    ":"               => lexer::Tok::Column,
    // "\n"              => lexer::Tok::Newline,
    "struct"          => lexer::Tok::Keyword(lexer::Keyword::Struct),
    "enum"            => lexer::Tok::Keyword(lexer::Keyword::Enum),
    "type"            => lexer::Tok::Keyword(lexer::Keyword::Type),
    "List"            => lexer::Tok::Keyword(lexer::Keyword::List),
    "Map"             => lexer::Tok::Keyword(lexer::Keyword::Map),
    "Optional"        => lexer::Tok::Keyword(lexer::Keyword::Optional),
    "String"          => lexer::Tok::Keyword(lexer::Keyword::Str),
    "UInt"            => lexer::Tok::Keyword(lexer::Keyword::UInt),
    "Int"             => lexer::Tok::Keyword(lexer::Keyword::Int),
    "Int8"            => lexer::Tok::Keyword(lexer::Keyword::Int8),
    "Int16"           => lexer::Tok::Keyword(lexer::Keyword::Int16),
    "Int32"           => lexer::Tok::Keyword(lexer::Keyword::Int32),
    "Int64"           => lexer::Tok::Keyword(lexer::Keyword::Int64),
    "UInt8"           => lexer::Tok::Keyword(lexer::Keyword::UInt8),
    "UInt16"          => lexer::Tok::Keyword(lexer::Keyword::UInt16),
    "UInt32"          => lexer::Tok::Keyword(lexer::Keyword::UInt32),
    "UInt64"          => lexer::Tok::Keyword(lexer::Keyword::UInt64),
    "Float"           => lexer::Tok::Keyword(lexer::Keyword::Float),
    "Bool"            => lexer::Tok::Keyword(lexer::Keyword::Bool),
    "Bytes"           => lexer::Tok::Keyword(lexer::Keyword::Bytes),
    "as"              => lexer::Tok::Keyword(lexer::Keyword::As),
    quoted_word       => lexer::Tok::Str(<String>),
    Word              => lexer::Tok::CapitalizedLabel(<String>),
    word              => lexer::Tok::Label(<String>),
  }
}
