#![allow(dead_code)]

use crate::ast::{
  Struct,
  Enum,
  Type,
  AtomicType,
  RefType,
  Field,
  EnumVariant,
  VariantValue,
  TopDeclaration,
  Alias,
  Builtin,
  location,
};

grammar;

pub TopDeclarations: Vec<TopDeclaration<String>> = {
  TopDeclaration* => <>,
}

pub TopDeclaration: TopDeclaration<String> = {
  Struct => TopDeclaration::Struct(<>),
  Enum => TopDeclaration::Enum(<>),
}

pub Struct: Struct<String> = {
  <s:@L> "struct" <name:Word> <params: TopLevelParams> "{" <fields:Comma<Field>> "}" <e:@L> => Struct {
    location: location(s, e),
    name: name.to_string(),
    type_parameters: params,
    fields,
  }
}

pub Enum: Enum<String> = {
  <s:@L> "enum" <name:Word> <params: TopLevelParams> "{" <variants:Comma<EnumVariant>> "}" <e:@L> => Enum {
    location: location(s, e),
    name: name.to_string(),
    type_parameters: params,
    variants,
  }
}

pub Alias: Alias<String> = {
  <s:@L> "type" <name:Word> "=" <alias:RefType> <e:@L> => Alias {
    location: location(s, e),
    name: name.to_string(),
    alias,
  }
}

pub RefType: RefType<String> = {
  <s:@L> <n:Word> <params:("<" <Comma<Type>> ">")?> <e:@L> => RefType {
    location: location(s, e),
    name: n.to_string(),
    type_parameters: params.unwrap_or(vec![]),
  },
}

pub Field: Field<String> = {
  <s:@L> <name:word> ":" <typ: Type> <e:@L> => Field {
    location: location(s, e),
    name: name.to_string(),
    typ,
  },
}

pub Type: Type<String> = {
  <atom:AtomicType> => Type::Atomic(atom),
  <s:@L> <n:Word> <types:("<" <Comma<Type>> ">")?> <e:@L> => Type::Reference(RefType {
    location: location(s, e),
    name: n.to_string(),
    type_parameters: types.unwrap_or(vec![]),
  }),

  // ditch the anon structs for use in list List<{...}> (at least for now)
  // "{" <fields:Comma<Field>> "}" => Type::Anonymous(fields),

  "List<" <typ:Type> ">" => Type::Builtin(Builtin::List(Box::new(typ))),
  "[" <typ:Type> "]" => Type::Builtin(Builtin::List(Box::new(typ))),

  "Optional<" <typ:Type> ">" => Type::Builtin(Builtin::Optional(Box::new(typ))),
  <typ:Type>"?" => Type::Builtin(Builtin::Optional(Box::new(typ))),

  "Map<" <key:Type> "," <val:Type> ">" => Type::Builtin(Builtin::Map(
    Box::new(key),
    Box::new(val),
  )),
}


TopLevelParams: Vec<String> = {
  <x:("<" <Comma<Word>> ">")?> => match x {
    None => vec![],
    Some(params) => {
      params.into_iter().map(|p| p.to_string()).collect()
    }
  }
}

EnumVariant: EnumVariant<String> = {
  <s:@L> <name:Word> <value:VariantValue> <alias:("as" <quoted_word>)?> <e:@L> => EnumVariant {
    location: location(s, e),
    name: name.to_string(),
    alias: alias.map(|x| x.to_string()),
    value,
  }
}

VariantValue: VariantValue<String> = {
  "{" <fields:Comma<Field>> "}" => VariantValue::StructCtor(
    fields
  ),
  <x:("(" <Comma<Type>> ")")?> => match x {
    None => VariantValue::OnlyCtor,
    Some(typs) => VariantValue::PositionalCtor(typs),
  }
}


pub AtomicType: AtomicType = {
  "String" => AtomicType::Str,
  "UInt" => AtomicType::UInt,
  "Int" => AtomicType::Int,
  "Int8" => AtomicType::Int8,
  "Int16" => AtomicType::Int16,
  "Int32" => AtomicType::Int32,
  "Int64" => AtomicType::Int64,
  "UInt8" => AtomicType::UInt8,
  "UInt16" => AtomicType::UInt16,
  "UInt32" => AtomicType::UInt32,
  "UInt64" => AtomicType::UInt64,
  "Float" => AtomicType::Float,
  "Bool" => AtomicType::Bool,
  "Bytes" => AtomicType::Bytes,
}

// comma separated vector of T, with optional trailing comma
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

quoted_word: String = <w:quoted_word_r> => w[1..w.len()-1].to_string();

match {
  "as",
  "struct",
  "enum",
  "type",
  "List",
  "Map",
  "Option",
  "String",
  "UInt",
  "Int",
  "Int8",
  "Int16",
  "Int32",
  "Int64",
  "UInt8",
  "UInt16",
  "UInt32",
  "UInt64",
  "Float",
  "Bool",
  "Bytes",
} else {
  r#""[^"]*""# => quoted_word_r,
} else {
  r"[A-Z]\w*" => Word,
} else {
  r"[a-z]\w*" => word,
  _,
}

